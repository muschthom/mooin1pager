{"version":3,"file":"content.min.js","sources":["../../src/local/content.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Course index main component.\r\n *\r\n * @module     core_courseformat/local/content\r\n * @class      core_courseformat/local/content\r\n * @copyright  2020 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport { BaseComponent } from \"core/reactive\";\r\nimport { debounce } from \"core/utils\";\r\nimport { getCurrentCourseEditor } from \"core_courseformat/courseeditor\";\r\nimport inplaceeditable from \"core/inplace_editable\";\r\nimport Section from \"format_mooin1pager/local/content/section\";\r\n//import CmItem from \"format_mooin1pager/local/content/section/cmitem\";\r\n// Course actions is needed for actions that are not migrated to components.\r\n//import courseActions from \"core_course/actions\";\r\n//import DispatchActions from \"format_mooin1pager/local/content/actions\";\r\nimport * as CourseEvents from \"core_course/events\";\r\n// The jQuery module is only used for interacting with Boostrap 4. It can we removed when MDL-71979 is integrated.\r\nimport jQuery from \"jquery\";\r\nimport Pending from \"core/pending\";\r\nimport log from \"core/log\";\r\nimport { get_string as getString } from \"core/str\";\r\nimport ModalFactory from \"core/modal_factory\";\r\nimport Templates from \"core/templates\";\r\nimport ModalEvents from \"core/modal_events\";\r\n//import mooin1pagerModal from \"../mooin1pagermodal\";\r\n\r\n//import CustomMutations from \"format_mooin1pager/local/courseeditor/custommutations\";\r\n\r\nexport default class Component extends BaseComponent {\r\n  /**\r\n   * Constructor hook.\r\n   *\r\n   * @param {Object} descriptor the component descriptor\r\n   */\r\n  create(descriptor) {\r\n    // Optional component name for debugging.\r\n    this.name = \"course_format\";\r\n    // Default query selectors.\r\n    this.selectors = {\r\n      SECTION: `[data-for='section']`,\r\n      SECTION_ITEM: `[data-for='section_title']`,\r\n      SECTION_CMLIST: `[data-for='cmlist']`,\r\n      COURSE_SECTIONLIST: `[data-for='course_sectionlist']`,\r\n      CM: `[data-for='cmitem']`,\r\n      PAGE: `#region-main`,\r\n      TOGGLER: `[data-action=\"togglecoursecontentsection\"]`,\r\n      COLLAPSE: `[data-toggle=\"collapse\"]`,\r\n      TOGGLEALL: `[data-toggle=\"toggleall\"]`,\r\n      // Formats can override the activity tag but a default one is needed to create new elements.\r\n      ACTIVITYTAG: \"li\",\r\n      SECTIONTAG: \"li\",\r\n      INDEXNUMBER: `[data-for='index_number']`,\r\n      NAVIGATIONWRAPPER: `[data-for='navigation_wrapper']`,\r\n      NAVIGATIONTITLE: `[data-for='navigationtitle']`,\r\n      BREADCRUMB: `[data-for='breadcrumb']`,\r\n      PROGRESSBAR: `[data-for='progressbar_container']`,\r\n      PROGRESSBARINNER: `[data-for='progressbar_inner']`,\r\n      COMPLETIONBUTTON: `[data-for='complete-section']`,\r\n      SECTIONPROGRESS: `[data-for='section-progress']`,\r\n      TITLEOVERLAY: `[data-for='title-overlay']`,\r\n      //H5P: `.parent-iframe`,\r\n    };\r\n    // Default classes to toggle on refresh.\r\n    this.classes = {\r\n      COLLAPSED: `collapsed`,\r\n      // Course content classes.\r\n      ACTIVITY: `activity`,\r\n      STATEDREADY: `stateready`,\r\n      SECTION: `section`,\r\n      SCROLLUP: `scroll-up`,\r\n      SCROLLDOWN: `scroll-down`,\r\n      FADEOUT: `fade-out`,\r\n      ACTIVE: `active`,\r\n    };\r\n    // Array to save dettached elements during element resorting.\r\n    this.dettachedCms = {};\r\n    this.dettachedSections = {};\r\n    // Index of sections and cms components.\r\n    this.sections = {};\r\n    this.cms = {};\r\n    // The page section return.\r\n    this.sectionReturn = descriptor.sectionReturn ?? 0;\r\n    this.debouncedReloads = new Map();\r\n\r\n    //Last Scrollposition\r\n    this.lastScroll = 0;\r\n  }\r\n\r\n  /**\r\n   * Static method to create a component instance form the mustahce template.\r\n   *\r\n   * @param {string} target the DOM main element or its ID\r\n   * @param {object} selectors optional css selector overrides\r\n   * @param {number} sectionReturn the content section return\r\n   * @return {Component}\r\n   */\r\n  static init(target, selectors, sectionReturn) {\r\n    return new Component({\r\n      element: document.getElementById(target),\r\n      reactive: getCurrentCourseEditor(),\r\n      selectors,\r\n      sectionReturn,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initial state ready method.\r\n   *\r\n   * @param {Object} state the state data\r\n   */\r\n  stateReady(state) {\r\n    this._indexContents();\r\n    // Activate section togglers.\r\n    this.addEventListener(this.element, \"click\", this._sectionTogglers);\r\n\r\n    // Collapse/Expand all sections button.\r\n    const toogleAll = this.getElement(this.selectors.TOGGLEALL);\r\n    if (toogleAll) {\r\n      // Ensure collapse menu button adds aria-controls attribute referring to each collapsible element.\r\n      const collapseElements = this.getElements(this.selectors.COLLAPSE);\r\n      const collapseElementIds = [...collapseElements].map(\r\n        (element) => element.id\r\n      );\r\n      toogleAll.setAttribute(\"aria-controls\", collapseElementIds.join(\" \"));\r\n\r\n      this.addEventListener(toogleAll, \"click\", this._allSectionToggler);\r\n      this.addEventListener(toogleAll, \"keydown\", (e) => {\r\n        // Collapse/expand all sections when Space key is pressed on the toggle button.\r\n        if (e.key === \" \") {\r\n          this._allSectionToggler(e);\r\n        }\r\n      });\r\n      this._refreshAllSectionsToggler(state);\r\n    }\r\n\r\n    if (this.reactive.supportComponents) {\r\n      DispatchActions.addActions({\r\n        completeSection: \"completeSection\",\r\n      });\r\n      const mutations = new CustomMutations();\r\n      // Actions are only available in edit mode.\r\n      if (this.reactive.isEditing) {\r\n        DispatchActions.addActions({\r\n          sectionSetChapter: \"sectionSetChapter\",\r\n          sectionUnsetChapter: \"sectionUnsetChapter\",\r\n        });\r\n\r\n        this.reactive.addMutations({\r\n          sectionSetChapter: mutations.sectionSetChapter,\r\n          sectionUnsetChapter: mutations.sectionUnsetChapter,\r\n          //completeSection: mutations.completeSection,\r\n        });\r\n      }\r\n      new DispatchActions(this);\r\n      this.reactive.addMutations({\r\n        completeSection: mutations.completeSection,\r\n        setContinueSection: mutations.setContinueSection,\r\n        getContinueSection: mutations.getContinueSection,\r\n        updateSectionprogress: mutations.updateSectionprogress,\r\n        setLastSectionModal: mutations.setLastSectionModal,\r\n        reloadAllSectionPrefixes: mutations.reloadAllSectionPrefixes,\r\n      });\r\n\r\n      // Mark content as state ready.\r\n      this.element.classList.add(this.classes.STATEDREADY);\r\n      this.reactive.dispatch(\"getContinueSection\", \"section\");\r\n      const sections = this.getElements(this.selectors.SECTION);\r\n      sections.forEach((section) => {\r\n        if (section.classList.contains(this.classes.ACTIVE)) {\r\n          this.reactive.dispatch(\r\n            \"setContinueSection\",\r\n            \"section\",\r\n            section.dataset.id\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    // Capture completion events.\r\n    this.addEventListener(\r\n      this.element,\r\n      CourseEvents.manualCompletionToggled,\r\n      this._completionHandler\r\n    );\r\n\r\n    // Capture page scroll to update page item.\r\n    this.addEventListener(\r\n      window,\r\n      \"scroll\",\r\n      this._scrollHandlerTina\r\n    );\r\n    //this._showLastSectionModal(state);\r\n    //this._hvpListener();\r\n  }\r\n\r\n  /**\r\n   * Setup sections toggler.\r\n   *\r\n   * Toggler click is delegated to the main course content element because new sections can\r\n   * appear at any moment and this way we prevent accidental double bindings.\r\n   *\r\n   * @param {Event} event the triggered event\r\n   */\r\n  _sectionTogglers(event) {\r\n    const sectionlink = event.target.closest(this.selectors.TOGGLER);\r\n    const closestCollapse = event.target.closest(this.selectors.COLLAPSE);\r\n    // Assume that chevron is the only collapse toggler in a section heading;\r\n    // I think this is the most efficient way to verify at the moment.\r\n    const isChevron = closestCollapse?.closest(this.selectors.SECTION_ITEM);\r\n\r\n    if (sectionlink || isChevron) {\r\n      const section = event.target.closest(this.selectors.SECTION);\r\n      const toggler = section.querySelector(this.selectors.COLLAPSE);\r\n      const isCollapsed =\r\n        toggler?.classList.contains(this.classes.COLLAPSED) ?? false;\r\n\r\n      if (isChevron || isCollapsed) {\r\n        // Update the state.\r\n        const sectionId = section.getAttribute(\"data-id\");\r\n        this.reactive.dispatch(\r\n          \"sectionContentCollapsed\",\r\n          [sectionId],\r\n          !isCollapsed\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the collapse/expand all sections button.\r\n   *\r\n   * Toggler click is delegated to the main course content element because new sections can\r\n   * appear at any moment and this way we prevent accidental double bindings.\r\n   *\r\n   * @param {Event} event the triggered event\r\n   */\r\n  _allSectionToggler(event) {\r\n    event.preventDefault();\r\n\r\n    const target = event.target.closest(this.selectors.TOGGLEALL);\r\n    const isAllCollapsed = target.classList.contains(this.classes.COLLAPSED);\r\n\r\n    const course = this.reactive.get(\"course\");\r\n    this.reactive.dispatch(\r\n      \"sectionContentCollapsed\",\r\n      course.sectionlist ?? [],\r\n      !isAllCollapsed\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the component watchers.\r\n   *\r\n   * @returns {Array} of watchers\r\n   */\r\n  getWatchers() {\r\n    // Section return is a global page variable but most formats define it just before start printing\r\n    // the course content. This is the reason why we define this page setting here.\r\n    this.reactive.sectionReturn = this.sectionReturn;\r\n\r\n    // Check if the course format is compatible with reactive components.\r\n    if (!this.reactive.supportComponents) {\r\n      return [];\r\n    }\r\n    return [\r\n      // State changes that require to reload some course modules.\r\n      { watch: `cm.visible:updated`, handler: this._reloadCm },\r\n      { watch: `cm.stealth:updated`, handler: this._reloadCm },\r\n      { watch: `cm.indent:updated`, handler: this._reloadCm },\r\n      // Update section number and title.\r\n      { watch: `section.number:updated`, handler: this._refreshSectionNumber },\r\n      // Collapse and expand sections.\r\n      {\r\n        watch: `section.contentcollapsed:updated`,\r\n        handler: this._refreshSectionCollapsed,\r\n      },\r\n      // Sections and cm sorting.\r\n      { watch: `transaction:start`, handler: this._startProcessing },\r\n      {\r\n        watch: `course.sectionlist:updated`,\r\n        handler: this._refreshCourseSectionlist,\r\n      },\r\n      { watch: `section.cmlist:updated`, handler: this._refreshSectionCmlist },\r\n      // Section visibility.\r\n      { watch: `section.visible:updated`, handler: this._reloadSection },\r\n      {\r\n        watch: `section.isChapter:updated`,\r\n        handler: this._updateChapters,\r\n      },\r\n      // Reindex sections and cms.\r\n      { watch: `state:updated`, handler: this._indexContents },\r\n      // State changes thaty require to reload course modules.\r\n      { watch: `cm.visible:updated`, handler: this._reloadCm },\r\n      { watch: `cm.sectionid:updated`, handler: this._reloadCm },\r\n      {\r\n        watch: `section.sectionprogress:updated`,\r\n        handler: this._updateSectionProgress,\r\n      },\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Update section collapsed state via bootstrap 4 if necessary.\r\n   *\r\n   * Formats that do not use bootstrap 4 must override this method in order to keep the section\r\n   * toggling working.\r\n   *\r\n   * @param {object} args\r\n   * @param {Object} args.state The state data\r\n   * @param {Object} args.element The element to update\r\n   */\r\n  _refreshSectionCollapsed({ state, element }) {\r\n    const target = this.getElement(this.selectors.SECTION, element.id);\r\n    if (!target) {\r\n      throw new Error(`Unknown section with ID ${element.id}`);\r\n    }\r\n    // Check if it is already done.\r\n    const toggler = target.querySelector(this.selectors.COLLAPSE);\r\n    const isCollapsed =\r\n      toggler?.classList.contains(this.classes.COLLAPSED) ?? false;\r\n\r\n    if (element.contentcollapsed !== isCollapsed) {\r\n      let collapsibleId =\r\n        toggler.dataset.target ?? toggler.getAttribute(\"href\");\r\n      if (!collapsibleId) {\r\n        return;\r\n      }\r\n      collapsibleId = collapsibleId.replace(\"#\", \"\");\r\n      const collapsible = document.getElementById(collapsibleId);\r\n      if (!collapsible) {\r\n        return;\r\n      }\r\n\r\n      // Course index is based on Bootstrap 4 collapsibles. To collapse them we need jQuery to\r\n      // interact with collapsibles methods. Hopefully, this will change in Bootstrap 5 because\r\n      // it does not require jQuery anymore (when MDL-71979 is integrated).\r\n      jQuery(collapsible).collapse(element.contentcollapsed ? \"hide\" : \"show\");\r\n    }\r\n\r\n    this._refreshAllSectionsToggler(state);\r\n  }\r\n\r\n  /**\r\n   * Refresh the collapse/expand all sections element.\r\n   *\r\n   * @param {Object} state The state data\r\n   */\r\n  _refreshAllSectionsToggler(state) {\r\n    const target = this.getElement(this.selectors.TOGGLEALL);\r\n    if (!target) {\r\n      return;\r\n    }\r\n    // Check if we have all sections collapsed/expanded.\r\n    let allcollapsed = true;\r\n    let allexpanded = true;\r\n    state.section.forEach((section) => {\r\n      allcollapsed = allcollapsed && section.contentcollapsed;\r\n      allexpanded = allexpanded && !section.contentcollapsed;\r\n    });\r\n    if (allcollapsed) {\r\n      target.classList.add(this.classes.COLLAPSED);\r\n      target.setAttribute(\"aria-expanded\", false);\r\n    }\r\n    if (allexpanded) {\r\n      target.classList.remove(this.classes.COLLAPSED);\r\n      target.setAttribute(\"aria-expanded\", true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup the component to start a transaction.\r\n   *\r\n   * Some of the course actions replaces the current DOM element with a new one before updating the\r\n   * course state. This means the component cannot preload any index properly until the transaction starts.\r\n   *\r\n   */\r\n  _startProcessing() {\r\n    // During a section or cm sorting, some elements could be dettached from the DOM and we\r\n    // need to store somewhare in case they are needed later.\r\n    this.dettachedCms = {};\r\n    this.dettachedSections = {};\r\n  }\r\n\r\n  /**\r\n   * Activity manual completion listener.\r\n   *\r\n   * @param {Event} event the custom ecent\r\n   */\r\n  _completionHandler({ detail }) {\r\n    if (detail === undefined) {\r\n      return;\r\n    }\r\n    this.reactive.dispatch(\"cmCompletion\", [detail.cmid], detail.completed);\r\n  }\r\n\r\n  /**\r\n   * Check the current page scroll and update the active element if necessary.\r\n   */\r\n  _scrollHandlerTina() {\r\n    var pageOffset = document.querySelector(this.selectors.PAGE).scrollTop;\r\n    var pageOffset = window.scrollY;\r\n    this._titleoverlay(pageOffset);\r\n    if (!this.reactive.isEditing) {\r\n      var pageOffset = window.scrollY;\r\n      this._dynamicHeader(pageOffset);\r\n    }\r\n\r\n    // const items = this.reactive\r\n    //   .getExporter()\r\n    //   .allItemsArray(this.reactive.state);\r\n    // // Check what is the active element now.\r\n    // let pageItem = null;\r\n    // items.every((item) => {\r\n    //   const index = item.type === \"section\" ? this.sections : this.cms;\r\n    //   if (index[item.id] === undefined) {\r\n    //     return true;\r\n    //   }\r\n\r\n    //   const element = index[item.id].element;\r\n    //   // Activities without url can only be page items in edit mode.\r\n    //   if (item.type === \"cm\" && !item.url && !this.reactive.isEditing) {\r\n    //     return pageOffset >= element.offsetTop;\r\n    //   }\r\n\r\n    //   pageItem = item;\r\n\r\n    //   return pageOffset >= element.offsetTop;\r\n    // });\r\n    // if (pageItem) {\r\n    //   //this.reactive.dispatch('setPageItem', pageItem.type, pageItem.id);\r\n    // }\r\n  }\r\n\r\n  _dynamicHeader(pageOffset) {\r\n    const navigationHeader = this.getElement(this.selectors.NAVIGATIONWRAPPER);\r\n    const title = this.getElement(this.selectors.NAVIGATIONTITLE);\r\n    const progressbarContainer = this.getElement(this.selectors.PROGRESSBAR);\r\n    const breadcrumb = this.getElement(this.selectors.BREADCRUMB);\r\n    if (title) {\r\n      var titleHeight = title.offsetHeight;\r\n      var progressbarContainerHeight = progressbarContainer.offsetHeight;\r\n      var removeOffset;\r\n      var screenHeight = window.innerHeight;\r\n      var removeOffsetNav = 0;\r\n      var removeOffsetBreadCrump = 60;\r\n      var removeOffsetNavUp = 60;\r\n\r\n      if (screenHeight <= 600) {\r\n        removeOffset = titleHeight + progressbarContainerHeight + 20;\r\n         removeOffsetNav = removeOffset;\r\n         removeOffsetBreadCrump = 60;\r\n         removeOffsetNavUp = 60;\r\n      } else {\r\n        removeOffset = titleHeight + 20;\r\n        removeOffsetNav = 0;\r\n        removeOffsetBreadCrump = 60;\r\n        removeOffsetNavUp = 60;\r\n      }\r\n\r\n      if (pageOffset <= 0) {\r\n        navigationHeader.style.transform = \"translateY(\" + 0 + \"px)\";\r\n        navigationHeader.classList.remove(this.classes.SCROLLUP);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        pageOffset > this.lastScroll &&\r\n        !navigationHeader.classList.contains(this.classes.SCROLLDOWN)\r\n      ) {\r\n        // down\r\n        navigationHeader.classList.remove(this.classes.SCROLLUP);\r\n        navigationHeader.classList.add(this.classes.SCROLLDOWN);\r\n        navigationHeader.style.transform =\r\n          \"translateY(-\" + removeOffsetNav + \"px)\";\r\n        breadcrumb.style.transform = \"translateY(\" + removeOffsetBreadCrump + \"px)\";\r\n        title.style.transform = \"translateY(\" + removeOffset + \"px)\";\r\n        //progressbarContainer.style.transform = \"translateY(\" + removeOffset + \"px)\";\r\n      } else if (\r\n        pageOffset < this.lastScroll &&\r\n        navigationHeader.classList.contains(this.classes.SCROLLDOWN)\r\n      ) {\r\n        // up\r\n        navigationHeader.classList.remove(this.classes.SCROLLDOWN);\r\n        navigationHeader.classList.add(this.classes.SCROLLUP);\r\n        navigationHeader.style.transform = \"translateY(\" + removeOffsetNavUp + \"px)\";\r\n        breadcrumb.style.transform = \"translateY(0px)\";\r\n        title.style.transform = \"translateY(0px)\";\r\n        progressbarContainer.style.transform = \"translateY(0px)\";\r\n      }\r\n\r\n      this.lastScroll = pageOffset;\r\n    }\r\n  }\r\n\r\n  _titleoverlay(pageOffset) {\r\n    const titleOverlay = this.getElement(this.selectors.TITLEOVERLAY);\r\n    if (titleOverlay) {\r\n      if (pageOffset > 130) {\r\n        titleOverlay.classList.add(this.classes.FADEOUT);\r\n      } else {\r\n        titleOverlay.classList.remove(this.classes.FADEOUT);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a course section when the section number changes.\r\n   *\r\n   * The courseActions module used for most course section tools still depends on css classes and\r\n   * section numbers (not id). To prevent inconsistencies when a section is moved, we need to refresh\r\n   * the\r\n   *\r\n   * Course formats can override the section title rendering so the frontend depends heavily on backend\r\n   * rendering. Luckily in edit mode we can trigger a title update using the inplace_editable module.\r\n   *\r\n   *\r\n   * @param {Object} state\r\n   * @param {Object} param.element details the update details.\r\n   */\r\n  _refreshSectionNumber({ state, element }) {\r\n    // Find the element.\r\n    const target = this.getElement(this.selectors.SECTION, element.id);\r\n    if (!target) {\r\n      // Job done. Nothing to refresh.\r\n      return;\r\n    }\r\n    // Update section numbers in all data, css and YUI attributes.\r\n    target.id = `section-${element.number}`;\r\n    // YUI uses section number as section id in data-sectionid, in principle if a format use components\r\n    // don't need this sectionid attribute anymore, but we keep the compatibility in case some plugin\r\n    // use it for legacy purposes.\r\n    target.dataset.sectionid = element.number;\r\n    // The data-number is the attribute used by components to store the section number.\r\n    target.dataset.number = element.number;\r\n    \r\n    //this._reloadSectionNames({ state: state, element: element });\r\n \r\n    \r\n    // Update title and title inplace editable, if any.\r\n    const inplace = inplaceeditable.getInplaceEditable(\r\n      target.querySelector(this.selectors.SECTION_ITEM)\r\n    );\r\n    if (inplace) {\r\n      // The course content HTML can be modified at any moment, so the function need to do some checkings\r\n      // to make sure the inplace editable still represents the same itemid.\r\n      const currentvalue = inplace.getValue();\r\n      const currentitemid = inplace.getItemId();\r\n      // Unnamed sections must be recalculated.\r\n      if (inplace.getValue() === \"\") {\r\n        // The value to send can be an empty value if it is a default name.\r\n        if (\r\n          currentitemid == element.id &&\r\n          (currentvalue != element.rawtitle || element.rawtitle == \"\")\r\n        ) {\r\n          inplace.setValue(element.rawtitle);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh a section cm list.\r\n   *\r\n   * @param {Object} param\r\n   * @param {Object} param.element details the update details.\r\n   */\r\n  _refreshSectionCmlist({ element }) {\r\n    const cmlist = element.cmlist ?? [];\r\n    const section = this.getElement(this.selectors.SECTION, element.id);\r\n    const listparent = section?.querySelector(this.selectors.SECTION_CMLIST);\r\n    // A method to create a fake element to be replaced when the item is ready.\r\n    const createCm = this._createCmItem.bind(this);\r\n    if (listparent) {\r\n      this._fixOrder(\r\n        listparent,\r\n        cmlist,\r\n        this.selectors.CM,\r\n        this.dettachedCms,\r\n        createCm\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refresh the section list.\r\n   *\r\n   * @param {Object} param\r\n   * @param {Object} param.element details the update details.\r\n   */\r\n  _refreshCourseSectionlist({ element }) {\r\n    // If we have a section return means we only show a single section so no need to fix order.\r\n    if (this.reactive.sectionReturn != 0) {\r\n      return;\r\n    }\r\n    const sectionlist = element.sectionlist ?? [];\r\n    const listparent = this.getElement(this.selectors.COURSE_SECTIONLIST);\r\n    // For now section cannot be created at a frontend level.\r\n    const createSection = this._createSectionItem.bind(this);\r\n    if (listparent) {\r\n      this._fixOrder(\r\n        listparent,\r\n        sectionlist,\r\n        this.selectors.SECTION,\r\n        this.dettachedSections,\r\n        createSection\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Regenerate content indexes.\r\n   *\r\n   * This method is used when a legacy action refresh some content element.\r\n   */\r\n  _indexContents() {\r\n    // Find unindexed sections.\r\n    this._scanIndex(this.selectors.SECTION, this.sections, (item) => {\r\n      return new Section(item);\r\n    });\r\n\r\n    // Find unindexed cms.\r\n    this._scanIndex(this.selectors.CM, this.cms, (item) => {\r\n      return new CmItem(item);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reindex a content (section or cm) of the course content.\r\n   *\r\n   * This method is used internally by _indexContents.\r\n   *\r\n   * @param {string} selector the DOM selector to scan\r\n   * @param {*} index the index attribute to update\r\n   * @param {*} creationhandler method to create a new indexed element\r\n   */\r\n  _scanIndex(selector, index, creationhandler) {\r\n    const items = this.getElements(`${selector}:not([data-indexed])`);\r\n    items.forEach((item) => {\r\n      if (!item?.dataset?.id) {\r\n        return;\r\n      }\r\n      // Delete previous item component.\r\n      if (index[item.dataset.id] !== undefined) {\r\n        index[item.dataset.id].unregister();\r\n      }\r\n      // Create the new component.\r\n      index[item.dataset.id] = creationhandler({\r\n        ...this,\r\n        element: item,\r\n      });\r\n      // Mark as indexed.\r\n      item.dataset.indexed = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reload a course module contents.\r\n   *\r\n   * Most course module HTML is still strongly backend dependant.\r\n   * Some changes require to get a new version of the module.\r\n   *\r\n   * @param {object} param0 the watcher details\r\n   * @param {object} param0.element the state object\r\n   */\r\n  _reloadCm({ element }) {\r\n    if (!this.getElement(this.selectors.CM, element.id)) {\r\n      return;\r\n    }\r\n    const debouncedReload = this._getDebouncedReloadCm(element.id);\r\n    debouncedReload();\r\n  }\r\n\r\n  /**\r\n   * Generate or get a reload CM debounced function.\r\n   * @param {Number} cmId\r\n   * @returns {Function} the debounced reload function\r\n   */\r\n  _getDebouncedReloadCm(cmId) {\r\n    const pendingKey = `courseformat/content:reloadCm_${cmId}`;\r\n    let debouncedReload = this.debouncedReloads.get(pendingKey);\r\n    if (debouncedReload) {\r\n      return debouncedReload;\r\n    }\r\n    const reload = () => {\r\n      const pendingReload = new Pending(pendingKey);\r\n      this.debouncedReloads.delete(pendingKey);\r\n      const cmitem = this.getElement(this.selectors.CM, cmId);\r\n      if (!cmitem) {\r\n        return pendingReload.resolve();\r\n      }\r\n      const promise = courseActions.refreshModule(cmitem, cmId);\r\n      promise\r\n        .then(() => {\r\n          this._indexContents();\r\n          return true;\r\n        })\r\n        .catch((error) => {\r\n          log.debug(error);\r\n        })\r\n        .finally(() => {\r\n          pendingReload.resolve();\r\n        });\r\n      return pendingReload;\r\n    };\r\n    debouncedReload = debounce(reload, 200, {\r\n      cancel: true,\r\n      pending: true,\r\n    });\r\n    this.debouncedReloads.set(pendingKey, debouncedReload);\r\n    return debouncedReload;\r\n  }\r\n\r\n  /**\r\n   * Cancel the active reload CM debounced function, if any.\r\n   * @param {Number} cmId\r\n   */\r\n  _cancelDebouncedReloadCm(cmId) {\r\n    const pendingKey = `courseformat/content:reloadCm_${cmId}`;\r\n    const debouncedReload = this.debouncedReloads.get(pendingKey);\r\n    if (!debouncedReload) {\r\n      return;\r\n    }\r\n    debouncedReload.cancel();\r\n    this.debouncedReloads.delete(pendingKey);\r\n  }\r\n\r\n  /**\r\n   * Reload a course section contents.\r\n   *\r\n   * Section HTML is still strongly backend dependant.\r\n   * Some changes require to get a new version of the section.\r\n   *\r\n   * @param {details} param0 the watcher details\r\n   * @param {object} param0.element the state object\r\n   */\r\n  _reloadSection({ state, element }) {\r\n    const pendingReload = new Pending(\r\n      `courseformat/content:reloadSection_${element.id}`\r\n    );\r\n    const sectionitem = this.getElement(this.selectors.SECTION, element.id);\r\n    if (sectionitem) {\r\n      // Cancel any pending reload because the section will reload cms too.\r\n      for (const cmId of element.cmlist) {\r\n        this._cancelDebouncedReloadCm(cmId);\r\n      }\r\n      this.reactive.dispatch('reloadAllSectionPrefixes', element);\r\n      const promise = courseActions.refreshSection(sectionitem, element.id);\r\n      \r\n      promise\r\n        .then(() => {\r\n          this._indexContents();\r\n          this._reloadSectionNames({ state: state, element: element });\r\n          return true;\r\n        })\r\n        .catch((error) => {\r\n          log.debug(error);\r\n        })\r\n        .finally(() => {\r\n          pendingReload.resolve();\r\n          \r\n        });\r\n    }\r\n  }\r\n\r\n  _reloadSectionNames({ state, element }) {\r\n    state.section.forEach((section) => {\r\n      if (section.number >= element.number) {\r\n        const number = this.getElement(this.selectors.INDEXNUMBER, section.id);\r\n        if (section.isChapter) {\r\n          number.innerHTML = section.isChapter;\r\n        } else {\r\n          // if (!section.visible) {\r\n          //   number.innerHTML = \"ausgeblendet\"\r\n          // } else {\r\n          //   //this.reactive.dispatch('reloadAllSectionPrefixes', element);\r\n          //   number.innerHTML = state.section.get(section.id).prefix;\r\n          // }\r\n          number.innerHTML = state.section.get(section.id).prefix;\r\n            //section.parentChapter + \".\" + section.innerChapterNumber;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _updateChapters({ state, element }) {\r\n    //this.reactive.dispatch('reloadAllSectionPrefixes', element);\r\n    //this._reloadSection({ element });\r\n    //window.console.log(\"chapter updated\");\r\n    this._reloadSection({\r\n            state: state, element: element,\r\n          });\r\n    // state.section.forEach((section) => {\r\n    //   if (section.number >= element.number) {\r\n    //     this._reloadSection({\r\n    //       element: section,\r\n    //     });\r\n        // const number = this.getElement(this.selectors.INDEXNUMBER, section.id);\r\n        // if (section.isChapter) {\r\n        //   number.innerHTML = section.isChapter;\r\n        // } else {\r\n        //   number.innerHTML =\r\n        //     section.parentChapter + \".\" + section.innerChapterNumber;\r\n        // }\r\n        //window.console.log(number);\r\n     // }\r\n    //});\r\n  }\r\n\r\n  //_reloadSectionNames({state, element}) {\r\n  // this._reloadSection({element});\r\n  // state.section.forEach(section => {\r\n  //   if (section.number > element.number) {\r\n  //     this._reloadSection({element: section});\r\n  //   }\r\n  // });\r\n  // const elements = this.getElements(this.selectors.INDEXNUMBER);\r\n  // elements.forEach(element => {\r\n  //   element.innerHTML = \"&nbsp3000:&nbsp\";\r\n  // });\r\n  //}\r\n\r\n  /**\r\n   * Create a new course module item in a section.\r\n   *\r\n   * Thos method will append a fake item in the container and trigger an ajax request to\r\n   * replace the fake element by the real content.\r\n   *\r\n   * @param {Element} container the container element (section)\r\n   * @param {Number} cmid the course-module ID\r\n   * @returns {Element} the created element\r\n   */\r\n  _createCmItem(container, cmid) {\r\n    const newItem = document.createElement(this.selectors.ACTIVITYTAG);\r\n    newItem.dataset.for = \"cmitem\";\r\n    newItem.dataset.id = cmid;\r\n    // The legacy actions.js requires a specific ID and class to refresh the CM.\r\n    newItem.id = `module-${cmid}`;\r\n    newItem.classList.add(this.classes.ACTIVITY);\r\n    container.append(newItem);\r\n    this._reloadCm({\r\n      element: this.reactive.get(\"cm\", cmid),\r\n    });\r\n    return newItem;\r\n  }\r\n\r\n  /**\r\n   * Create a new section item.\r\n   *\r\n   * This method will append a fake item in the container and trigger an ajax request to\r\n   * replace the fake element by the real content.\r\n   *\r\n   * @param {Element} container the container element (section)\r\n   * @param {Number} sectionid the course-module ID\r\n   * @returns {Element} the created element\r\n   */\r\n  _createSectionItem(container, sectionid) {\r\n    const section = this.reactive.get(\"section\", sectionid);\r\n    const newItem = document.createElement(this.selectors.SECTIONTAG);\r\n    newItem.dataset.for = \"section\";\r\n    newItem.dataset.id = sectionid;\r\n    newItem.dataset.number = section.number;\r\n    // The legacy actions.js requires a specific ID and class to refresh the section.\r\n    newItem.id = `section-${sectionid}`;\r\n    newItem.classList.add(this.classes.SECTION);\r\n    container.append(newItem);\r\n    this._reloadSection({\r\n      element: section,\r\n    });\r\n    return newItem;\r\n  }\r\n\r\n  /**\r\n   * Fix/reorder the section or cms order.\r\n   *\r\n   * @param {Element} container the HTML element to reorder.\r\n   * @param {Array} neworder an array with the ids order\r\n   * @param {string} selector the element selector\r\n   * @param {Object} dettachedelements a list of dettached elements\r\n   * @param {function} createMethod method to create missing elements\r\n   */\r\n  async _fixOrder(\r\n    container,\r\n    neworder,\r\n    selector,\r\n    dettachedelements,\r\n    createMethod\r\n  ) {\r\n    if (container === undefined) {\r\n      return;\r\n    }\r\n\r\n    // Empty lists should not be visible.\r\n    if (!neworder.length) {\r\n      container.classList.add(\"hidden\");\r\n      container.innerHTML = \"\";\r\n      return;\r\n    }\r\n\r\n    // Grant the list is visible (in case it was empty).\r\n    container.classList.remove(\"hidden\");\r\n\r\n    // Move the elements in order at the beginning of the list.\r\n    neworder.forEach((itemid, index) => {\r\n      let item =\r\n        this.getElement(selector, itemid) ??\r\n        dettachedelements[itemid] ??\r\n        createMethod(container, itemid);\r\n      if (item === undefined) {\r\n        // Missing elements cannot be sorted.\r\n        return;\r\n      }\r\n      // Get the current elemnt at that position.\r\n      const currentitem = container.children[index];\r\n      if (currentitem === undefined) {\r\n        container.append(item);\r\n        return;\r\n      }\r\n      if (currentitem !== item) {\r\n        container.insertBefore(item, currentitem);\r\n      }\r\n    });\r\n\r\n    // Dndupload add a fake element we need to keep.\r\n    let dndFakeActivity;\r\n\r\n    // Remove the remaining elements.\r\n    while (container.children.length > neworder.length) {\r\n      const lastchild = container.lastChild;\r\n      if (lastchild?.classList?.contains(\"dndupload-preview\")) {\r\n        dndFakeActivity = lastchild;\r\n      } else {\r\n        dettachedelements[lastchild?.dataset?.id ?? 0] = lastchild;\r\n      }\r\n      container.removeChild(lastchild);\r\n    }\r\n    // Restore dndupload fake element.\r\n    if (dndFakeActivity) {\r\n      container.append(dndFakeActivity);\r\n    }\r\n  }\r\n\r\n  async _updateSectionProgress({ state, element }) {\r\n    const progressbar = this.getElement(this.selectors.PROGRESSBARINNER);\r\n    progressbar.style.width = element.sectionprogress + \"%\";\r\n\r\n    const sectionprogress = this.getElement(this.selectors.SECTIONPROGRESS);\r\n    sectionprogress.innerText = element.sectionprogress;\r\n\r\n    const completionbutton = this.getElement(this.selectors.COMPLETIONBUTTON);\r\n    if (completionbutton) {\r\n      completionbutton.disabled = true;\r\n\r\n      const text = await getString(\"page_read\", \"format_mooin1pager\");\r\n      const checkMark = document.createElement(\"i\");\r\n      checkMark.classList.add(\"bi\", \"bi-check\");\r\n      completionbutton.innerText = text;\r\n      completionbutton.appendChild(checkMark);\r\n    }\r\n\r\n    const currentSection = state.section.get(element.id);\r\n    let nextSection = null;\r\n\r\n    let completed = true;\r\n    let allCompleted = true;\r\n\r\n    state.section.forEach((section) => {\r\n      if (!section.isCompleted && section.number != 0 && !section.isChapter) {\r\n        allCompleted = false;\r\n      }\r\n    });\r\n\r\n    state.section.forEach((section) => {\r\n      if (\r\n        section.parentChapter === currentSection.parentChapter &&\r\n        !section.isCompleted\r\n      ) {\r\n        completed = false;\r\n      }\r\n      if (\r\n        Number(section.parentChapter) ===\r\n          Number(currentSection.parentChapter) + 1 &&\r\n        section.isFirstSectionOfChapter\r\n      ) {\r\n        nextSection = section;\r\n      }\r\n    });\r\n\r\n    if (allCompleted) {\r\n      this._showCourseCompletedModal(state, nextSection);\r\n    } else if (completed) {\r\n      this._showChapterCompletedModal(state, nextSection);\r\n    }\r\n  }\r\n\r\n  async _showChapterCompletedModal(state, nextSection) {\r\n    const modal = await ModalFactory.create({\r\n      type: mooin1pagerModal.TYPE,\r\n      title: await getString(\r\n        \"modal_chapter_complete_title\",\r\n        \"format_mooin1pager\"\r\n      ),\r\n      body: Templates.render(\r\n        \"format_mooin1pager/local/content/modals/chaptercomplete\",\r\n        {}\r\n      ),\r\n      footer: Templates.render(\r\n        \"format_mooin1pager/local/content/modals/completechapterfooter\",\r\n        { nextSection }\r\n      ),\r\n      scrollable: false,\r\n    });\r\n    modal.show();\r\n    modal.showFooter();\r\n  }\r\n\r\n  async _showCourseCompletedModal(state) {\r\n    const modal = await ModalFactory.create({\r\n      type: mooin1pagerModal.TYPE,\r\n      title: await getString(\r\n        \"modal_course_complete_title\",\r\n        \"format_mooin1pager\"\r\n      ),\r\n      body: Templates.render(\r\n        \"format_mooin1pager/local/content/modals/coursecomplete\",\r\n        {}\r\n      ),\r\n      footer: Templates.render(\r\n        \"format_mooin1pager/local/content/modals/modalfooterclose\",\r\n        {}\r\n      ),\r\n      scrollable: false,\r\n    });\r\n    modal.show();\r\n    modal.showFooter();\r\n  }\r\n\r\n  // _hvpListener() {\r\n  //   var parentIFrames = this.getElements(this.selectors.H5P);\r\n  //   if (parentIFrames.length > 0) {\r\n  //       parentIFrames.forEach((parentIFrame) => {\r\n  //           if (parentIFrame.contentDocument) {\r\n  //               var parentIFrameContent = parentIFrame.contentDocument || parentIFrame.contentWindow.document;\r\n\r\n  //               var nestedIFrame = parentIFrameContent.querySelector(\".h5p-iframe\");\r\n\r\n  //               if (nestedIFrame) {\r\n  //                   var H5P = nestedIFrame.contentWindow.H5P;\r\n  //                   H5P.externalDispatcher.on(\"xAPI\", this._hvpprogress.bind(this));\r\n  //               } else {\r\n  //                   setTimeout(this._hvpListener.bind(this), 100);\r\n  //               }\r\n  //           } else {\r\n  //               setTimeout(this._hvpListener.bind(this), 100);\r\n  //           }\r\n  //       });\r\n  //   }\r\n  // }\r\n\r\n  // _hvpprogress(event) {\r\n  //   window.console.log(event);\r\n  //   this.reactive.dispatch();\r\n  //   const progress = this.getElement(this.selectors.PROGRESSBARINNER);\r\n  //   let computedStyle = window.getComputedStyle(progress);\r\n  //   let width = computedStyle.width;\r\n  //   if (event.getVerb() === \"completed\") {\r\n  //     var score = event.getScore();\r\n  //     var maxScore = event.getMaxScore();\r\n  //     var percentage = (score / maxScore) * 100;\r\n  //     let newPercentage = width + percentage;\r\n  //     progress.style.width = newPercentage + \"%\";\r\n  //     console.log(score);\r\n  //     console.log(maxScore);\r\n  //     console.log(percentage);\r\n  //     console.log(newPercentage);\r\n  //     console.log(width);\r\n  //   }\r\n  // }\r\n\r\n  // async _showLastSectionModal(state) {\r\n  //   const course = state.course;\r\n  //   const pageItem = course.pageItem;\r\n  //   window.console.log(this.element.pageItem.sectionId);\r\n  //   const section = state.section.get(this.id);\r\n  //   if (section.showLastSectionModal) {\r\n  //     const modal = await ModalFactory.create({\r\n  //       type: mooin1pagerModal.TYPE,\r\n  //       title: await getString(\r\n  //         \"modal_last_section_of_chapter_title\",\r\n  //         \"format_mooin1pager\"\r\n  //       ),\r\n  //       body: Templates.render(\r\n  //         \"format_mooin1pager/local/content/modals/lastsection\",\r\n  //         {}\r\n  //       ),\r\n  //     });\r\n  //     modal.show();\r\n  //   }\r\n  // }\r\n}\r\n"],"names":["Component","BaseComponent","create","descriptor","name","selectors","SECTION","SECTION_ITEM","SECTION_CMLIST","COURSE_SECTIONLIST","CM","PAGE","TOGGLER","COLLAPSE","TOGGLEALL","ACTIVITYTAG","SECTIONTAG","INDEXNUMBER","NAVIGATIONWRAPPER","NAVIGATIONTITLE","BREADCRUMB","PROGRESSBAR","PROGRESSBARINNER","COMPLETIONBUTTON","SECTIONPROGRESS","TITLEOVERLAY","classes","COLLAPSED","ACTIVITY","STATEDREADY","SCROLLUP","SCROLLDOWN","FADEOUT","ACTIVE","dettachedCms","dettachedSections","sections","cms","sectionReturn","debouncedReloads","Map","lastScroll","target","element","document","getElementById","reactive","stateReady","state","_indexContents","addEventListener","this","_sectionTogglers","toogleAll","getElement","collapseElementIds","getElements","map","id","setAttribute","join","_allSectionToggler","e","key","_refreshAllSectionsToggler","supportComponents","DispatchActions","addActions","completeSection","mutations","CustomMutations","isEditing","sectionSetChapter","sectionUnsetChapter","addMutations","setContinueSection","getContinueSection","updateSectionprogress","setLastSectionModal","reloadAllSectionPrefixes","classList","add","dispatch","forEach","section","contains","dataset","CourseEvents","manualCompletionToggled","_completionHandler","window","_scrollHandlerTina","event","sectionlink","closest","closestCollapse","isChevron","toggler","querySelector","isCollapsed","sectionId","getAttribute","preventDefault","isAllCollapsed","course","get","sectionlist","getWatchers","watch","handler","_reloadCm","_refreshSectionNumber","_refreshSectionCollapsed","_startProcessing","_refreshCourseSectionlist","_refreshSectionCmlist","_reloadSection","_updateChapters","_updateSectionProgress","Error","contentcollapsed","collapsibleId","replace","collapsible","collapse","allcollapsed","allexpanded","remove","detail","undefined","cmid","completed","pageOffset","scrollTop","scrollY","_titleoverlay","_dynamicHeader","navigationHeader","title","progressbarContainer","breadcrumb","removeOffset","titleHeight","offsetHeight","progressbarContainerHeight","removeOffsetNav","removeOffsetBreadCrump","removeOffsetNavUp","innerHeight","style","transform","titleOverlay","number","sectionid","inplace","inplaceeditable","getInplaceEditable","currentvalue","getValue","currentitemid","getItemId","rawtitle","setValue","cmlist","listparent","createCm","_createCmItem","bind","_fixOrder","createSection","_createSectionItem","_scanIndex","item","Section","CmItem","selector","index","creationhandler","_item$dataset","unregister","indexed","_getDebouncedReloadCm","debouncedReload","cmId","pendingKey","pendingReload","Pending","delete","cmitem","resolve","courseActions","refreshModule","then","catch","error","debug","finally","cancel","pending","set","_cancelDebouncedReloadCm","sectionitem","refreshSection","_reloadSectionNames","isChapter","innerHTML","prefix","container","newItem","createElement","for","append","neworder","dettachedelements","createMethod","length","dndFakeActivity","itemid","currentitem","children","insertBefore","lastchild","lastChild","_lastchild$classList","_lastchild$dataset","removeChild","width","sectionprogress","innerText","completionbutton","disabled","text","checkMark","appendChild","currentSection","nextSection","allCompleted","isCompleted","parentChapter","Number","isFirstSectionOfChapter","_showCourseCompletedModal","_showChapterCompletedModal","modal","ModalFactory","type","mooin1pagerModal","TYPE","body","Templates","render","footer","scrollable","show","showFooter"],"mappings":"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"}